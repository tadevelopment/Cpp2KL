{
  "header": "
#include \"ai.h\"
  ",
  "parameterprefix": "f2a",
  "functionentry": "F2A_TRY_STATEMENT", 
  "functionexit": "F2A_CATCH_STATEMENT", 
  "functionexitreturn": "F2A_CATCH_STATEMENT_RETURN",
  "typemapping": {
    "Boolean": {
      "ctype": "bool",
      "from": "conv_from_baseType<KL::Boolean, bool>",
      "to": "conv_to_baseType<KL::Boolean, bool>",
      "defaultvalue": "false"
    },
    "SInt32": {
      "ctype": "int",
      "from": "conv_from_baseType<KL::SInt32, int>",
      "to": "conv_to_baseType<KL::SInt32, int>",
      "defaultvalue": "0"
    },
    "UInt32": {
      "ctype": "unsigned int",
      "from": "conv_from_baseType<KL::UInt32, unsigned int>",
      "to": "conv_to_baseType<KL::UInt32, unsigned int>",
      "defaultvalue": "0"
    },
    "Float32": {
      "ctype": "float",
      "from": "conv_from_baseType<KL::Float32, float>",
      "to": "conv_to_baseType<KL::Float32, float>",
      "defaultvalue": "0"
    },
    "Float64": {
      "ctype": "double",
      "from": "conv_from_baseType<KL::Float64, double>",
      "to": "conv_to_baseType<KL::Float64, double>",
      "defaultvalue": "0"
    },
    "String": {
      "ctype": "std::string",
      "from": "conv_from_String",
      "to": "conv_to_String",
      "defaultvalue": "\"\""
    },
    "Box3": {
      "ctype": "Abc::Box3d",
      "from": "conv_from_Box3",
      "to": "conv_to_Box3"
    },
    "Mat33": {
      "ctype": "Abc::M33d",
      "from": "conv_from_Mat33",
      "to": "conv_to_Mat33"
    },
    "Mat44": {
      "ctype": "Abc::M44d",
      "from": "conv_from_Mat44",
      "to": "conv_to_Mat44"
    },
    "AlembicTimeSamplingPair": {
      "ctype": "std::pair<Abc::index_t, Abc::chrono_t>",
      "from": "conv_from_AlembicTimeSamplingPair",
      "to": "conv_to_AlembicTimeSamplingPair"
    },
    "AlembicIArchive": {
      "ctype": "Abc::IArchive*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIArchive, Abc::IArchive>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIArrayProperty": {
      "ctype": "Abc::IArrayProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICameraSchema": {
      "ctype": "AbcG::ICameraSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicICameraSchema, AbcG::ICameraSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICameraSchema, AbcG::ICameraSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICamera": {
      "ctype": "AbcG::ICamera*",
      "from": "conv_from_AbcBasePtr<KL::AlembicICamera, AbcG::ICamera>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICamera, AbcG::ICamera>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICompoundProperty": {
      "ctype": "Abc::ICompoundProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICurvesSchema": {
      "ctype": "AbcG::ICurvesSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicICurvesSchema, AbcG::ICurvesSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICurvesSchema, AbcG::ICurvesSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICurves": {
      "ctype": "AbcG::ICurves*",
      "from": "conv_from_AbcBasePtr<KL::AlembicICurves, AbcG::ICurves>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICurves, AbcG::ICurves>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicICurvesSample": {
      "ctype": "AbcG::ICurvesSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicICurvesSample, AbcG::ICurvesSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicICurvesSample, AbcG::ICurvesSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIFaceSetSchema": {
      "ctype": "AbcG::IFaceSetSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIFaceSetSchema, AbcG::IFaceSetSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIFaceSetSchema, AbcG::IFaceSetSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIFaceSet": {
      "ctype": "AbcG::IFaceSet*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIFaceSet, AbcG::IFaceSet>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIFaceSet, AbcG::IFaceSet>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIFaceSetSample": {
      "ctype": "AbcG::IFaceSetSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIFaceSetSample, AbcG::IFaceSetSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIFaceSetSample, AbcG::IFaceSetSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicILightSchema": {
      "ctype": "AbcG::ILightSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicILightSchema, AbcG::ILightSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicILightSchema, AbcG::ILightSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicILight": {
      "ctype": "AbcG::ILight*",
      "from": "conv_from_AbcBasePtr<KL::AlembicILight, AbcG::ILight>",
      "to": "conv_to_AbcBasePtr<KL::AlembicILight, AbcG::ILight>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicINuPatchSchema": {
      "ctype": "AbcG::INuPatchSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicINuPatchSchema, AbcG::INuPatchSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicINuPatchSchema, AbcG::INuPatchSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicINuPatch": {
      "ctype": "AbcG::INuPatch*",
      "from": "conv_from_AbcBasePtr<KL::AlembicINuPatch, AbcG::INuPatch>",
      "to": "conv_to_AbcBasePtr<KL::AlembicINuPatch, AbcG::INuPatch>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicINuPatchSample": {
      "ctype": "AbcG::INuPatchSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicINuPatchSample, AbcG::INuPatchSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicINuPatchSample, AbcG::INuPatchSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIObject": {
      "ctype": "Abc::IObject*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIObject, Abc::IObject>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIObject, Abc::IObject>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPointsSchema": {
      "ctype": "AbcG::IPointsSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPointsSchema, AbcG::IPointsSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPointsSchema, AbcG::IPointsSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPoints": {
      "ctype": "AbcG::IPoints*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPoints, AbcG::IPoints>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPoints, AbcG::IPoints>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPointsSample": {
      "ctype": "AbcG::IPointsSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPointsSample, AbcG::IPointsSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPointsSample, AbcG::IPointsSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPolyMeshSchema": {
      "ctype": "AbcG::IPolyMeshSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPolyMeshSchema, AbcG::IPolyMeshSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPolyMeshSchema, AbcG::IPolyMeshSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPolyMesh": {
      "ctype": "AbcG::IPolyMesh*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPolyMesh, AbcG::IPolyMesh>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPolyMesh, AbcG::IPolyMesh>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIPolyMeshSample": {
      "ctype": "AbcG::IPolyMeshSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIPolyMeshSample, AbcG::IPolyMeshSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIPolyMeshSample, AbcG::IPolyMeshSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicISampleSelector": {
      "ctype": "Abc::ISampleSelector*",
      "from": "conv_from_AbcBasePtr<KL::AlembicISampleSelector, Abc::ISampleSelector>",
      "to": "conv_to_AbcBasePtr<KL::AlembicISampleSelector, Abc::ISampleSelector>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIScalarProperty": {
      "ctype": "Abc::IScalarProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicISubDSchema": {
      "ctype": "AbcG::ISubDSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicISubDSchema, AbcG::ISubDSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicISubDSchema, AbcG::ISubDSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicISubD": {
      "ctype": "AbcG::ISubD*",
      "from": "conv_from_AbcBasePtr<KL::AlembicISubD, AbcG::ISubD>",
      "to": "conv_to_AbcBasePtr<KL::AlembicISubD, AbcG::ISubD>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicISubDSample": {
      "ctype": "AbcG::ISubDSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicISubDSample, AbcG::ISubDSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicISubDSample, AbcG::ISubDSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIXformSchema": {
      "ctype": "AbcG::IXformSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIXformSchema, AbcG::IXformSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIXformSchema, AbcG::IXformSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIXform": {
      "ctype": "AbcG::IXform*",
      "from": "conv_from_AbcBasePtr<KL::AlembicIXform, AbcG::IXform>",
      "to": "conv_to_AbcBasePtr<KL::AlembicIXform, AbcG::IXform>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicMetaData": {
      "ctype": "Abc::MetaData *",
      "from": "conv_from_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>",
      "to": "conv_to_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOArchive": {
      "ctype": "Abc::OArchive*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOArchive, Abc::OArchive>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOArchive, Abc::OArchive>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOArrayProperty": {
      "ctype": "Abc::OArrayProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOArrayProperty, Abc::OArrayProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOArrayProperty, Abc::OArrayProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCameraSchema": {
      "ctype": "AbcG::OCameraSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCameraSchema, AbcG::OCameraSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCameraSchema, AbcG::OCameraSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCamera": {
      "ctype": "AbcG::OCamera*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCamera, AbcG::OCamera>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCamera, AbcG::OCamera>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCompoundProperty": {
      "ctype": "Abc::OCompoundProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCompoundProperty, Abc::OCompoundProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCompoundProperty, Abc::OCompoundProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCurves": {
      "ctype": "AbcG::OCurves*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCurves, AbcG::OCurves>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCurves, AbcG::OCurves>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCurvesSchema": {
      "ctype": "AbcG::OCurvesSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCurvesSchema, AbcG::OCurvesSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCurvesSchema, AbcG::OCurvesSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOCurvesSample": {
      "ctype": "AbcG::OCurvesSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOCurvesSample, AbcG::OCurvesSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOCurvesSample, AbcG::OCurvesSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOFaceSetSchema": {
      "ctype": "AbcG::OFaceSetSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOFaceSetSchema, AbcG::OFaceSetSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOFaceSetSchema, AbcG::OFaceSetSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOFaceSet": {
      "ctype": "AbcG::OFaceSet*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOFaceSet, AbcG::OFaceSet>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOFaceSet, AbcG::OFaceSet>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOFaceSetSample": {
      "ctype": "AbcG::OFaceSetSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOFaceSetSample, AbcG::OFaceSetSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOFaceSetSample, AbcG::OFaceSetSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOLightSchema": {
      "ctype": "AbcG::OLightSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOLightSchema, AbcG::OLightSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOLightSchema, AbcG::OLightSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOLight": {
      "ctype": "AbcG::OLight*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOLight, AbcG::OLight>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOLight, AbcG::OLight>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicONuPatchSchema": {
      "ctype": "AbcG::ONuPatchSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicONuPatchSchema, AbcG::ONuPatchSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicONuPatchSchema, AbcG::ONuPatchSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicONuPatch": {
      "ctype": "AbcG::ONuPatch*",
      "from": "conv_from_AbcBasePtr<KL::AlembicONuPatch, AbcG::ONuPatch>",
      "to": "conv_to_AbcBasePtr<KL::AlembicONuPatch, AbcG::ONuPatch>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicONuPatchSample": {
      "ctype": "AbcG::ONuPatchSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicONuPatchSample, AbcG::ONuPatchSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicONuPatchSample, AbcG::ONuPatchSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOObject": {
      "ctype": "Abc::OObject*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOObject, Abc::OObject>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOObject, Abc::OObject>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPointsSchema": {
      "ctype": "AbcG::OPointsSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPointsSchema, AbcG::OPointsSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPointsSchema, AbcG::OPointsSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPoints": {
      "ctype": "AbcG::OPoints*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPoints, AbcG::OPoints>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPoints, AbcG::OPoints>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPointsSample": {
      "ctype": "AbcG::OPointsSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPointsSample, AbcG::OPointsSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPointsSample, AbcG::OPointsSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPolyMeshSchema": {
      "ctype": "AbcG::OPolyMeshSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPolyMeshSchema, AbcG::OPolyMeshSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPolyMeshSchema, AbcG::OPolyMeshSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPolyMesh": {
      "ctype": "AbcG::OPolyMesh*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPolyMesh, AbcG::OPolyMesh>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPolyMesh, AbcG::OPolyMesh>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOPolyMeshSample": {
      "ctype": "AbcG::OPolyMeshSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOPolyMeshSample, AbcG::OPolyMeshSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOPolyMeshSample, AbcG::OPolyMeshSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOScalarProperty": {
      "ctype": "Abc::OScalarProperty*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOScalarProperty, Abc::OScalarProperty>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOScalarProperty, Abc::OScalarProperty>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOSubDSchema": {
      "ctype": "AbcG::OSubDSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOSubDSchema, AbcG::OSubDSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOSubDSchema, AbcG::OSubDSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOSubD": {
      "ctype": "AbcG::OSubD*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOSubD, AbcG::OSubD>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOSubD, AbcG::OSubD>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOSubDSample": {
      "ctype": "AbcG::OSubDSchema::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOSubDSample, AbcG::OSubDSchema::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOSubDSample, AbcG::OSubDSchema::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOXformSchema": {
      "ctype": "AbcG::OXformSchema*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOXformSchema, AbcG::OXformSchema>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOXformSchema, AbcG::OXformSchema>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOXform": {
      "ctype": "AbcG::OXform*",
      "from": "conv_from_AbcBasePtr<KL::AlembicOXform, AbcG::OXform>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOXform, AbcG::OXform>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicPropertyHeader": {
      "ctype": "Abc::PropertyHeader *",
      "from": "conv_from_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>",
      "to": "conv_to_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicTimeSampling": {
      "ctype": "Abc::TimeSamplingPtr",
      "from": "conv_from_AbcBase<KL::AlembicTimeSampling, Abc::TimeSampling>",
      "to": "conv_to_AbcBase<KL::AlembicTimeSampling, Abc::TimeSampling>",
      "methodop": "->"
    },
    "AlembicTimeSampling": {
      "ctype": "Abc::TimeSamplingPtr",
      "from": "conv_from_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>",
      "to": "conv_to_AbcBase<KL::AlembicTimeSampling, Abc::TimeSamplingPtr>",
      "methodop": "->"
    },
    "AlembicTimeSamplingType": {
      "ctype": "Abc::TimeSamplingType",
      "from": "conv_from_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>",
      "to": "conv_to_AbcBase<KL::AlembicTimeSamplingType, Abc::TimeSamplingType>",
      "methodop": "."
    },
    "AlembicCameraSample": {
      "ctype": "AbcG::CameraSample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicCameraSample, AbcG::CameraSample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicCameraSample, AbcG::CameraSample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicDataType": {
      "ctype": "Abc::DataType",
      "from": "conv_from_AbcBase<KL::AlembicDataType, Abc::DataType>",
      "to": "conv_to_AbcBase<KL::AlembicDataType, Abc::DataType>",
      "methodop": "."
    },
    "AlembicXformSample": {
      "ctype": "AbcG::XformSample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicXformSample, AbcG::XformSample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicXformSample, AbcG::XformSample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIVec2VfGeomParam": {
      "ctype": "AbcG::ITypedGeomParam<Abc::V2fTPTraits> *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >",
      "to": "conv_to_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIFloat32GeomParam": {
      "ctype": "AbcG::ITypedGeomParam<Abc::Float32TPTraits> *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIFloat32GeomParam, AbcG::ITypedGeomParam<Abc::Float32TPTraits> >",
      "to": "conv_to_AbcBasePtr<KL::AlembicIFloat32GeomParam, AbcG::ITypedGeomParam<Abc::Float32TPTraits> >",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicIVec3NfGeomParam": {
      "ctype": "AbcG::ITypedGeomParam<Abc::N3fTPTraits> *",
      "from": "conv_from_AbcBasePtr<KL::AlembicIVec3NfGeomParam, AbcG::ITypedGeomParam<Abc::N3fTPTraits> >",
      "to": "conv_to_AbcBasePtr<KL::AlembicIVec3NfGeomParam, AbcG::ITypedGeomParam<Abc::N3fTPTraits> >",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOVec2VfGeomParamSample": {
      "ctype": "AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOFloat32GeomParamSample": {
      "ctype": "AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOFloat32GeomParamSample, AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOFloat32GeomParamSample, AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    },
    "AlembicOVec3NfGeomParamSample": {
      "ctype": "AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample *",
      "from": "conv_from_AbcBasePtr<KL::AlembicOVec3NfGeomParamSample, AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample>",
      "to": "conv_to_AbcBasePtr<KL::AlembicOVec3NfGeomParamSample, AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample>",
      "methodop": "->",
      "dereferenceasmethodparam": true
    }
  },
  "functionbodies": {
    "AlembicIArchive_construct": "  this_->handle = NULL;\n  ",
    "AlembicIArchive_free": "  free_AbcBasePtr(Abc::IArchive)\n  ",
    "AlembicIArchive_constructFromString": "
  if(abcFileName.length() == 0)
  {
    setError(\"AlembicIArchive_constructFromString: No fileName specified.\");
    return;
  }
  AbcF::IFactory factory;
  factory.setPolicy(Abc::ErrorHandler::kThrowPolicy);

  AbcF::IFactory::CoreType coreType;
  Abc::IArchive * abcArchive = new Abc::IArchive(factory.getArchive(fileName.data(), coreType));
  if ( coreType == AbcF::IFactory::kUnknown )
  {
    setError(\"AlembicIArchive_constructFromString: Unknown core type / file not found.\");
    delete(abcArchive);
    return;
  }
  this_->handle = new PtrHandle<Abc::IArchive>(abcArchive, true);
    ",
    "AlembicCameraSample_construct": "  construct_AbcBasePtr(AbcG::CameraSample)\n  ",
    "AlembicCameraSample_free": "  free_AbcBasePtr(AbcG::CameraSample)\n  ",
    "AlembicCameraSample_construct4Args": "  this_->handle = new PtrHandle<AbcG::CameraSample>(new AbcG::CameraSample(abcTop, abcBottom, abcLeft, abcRight), true);\n  ",
    "AlembicDataType_construct": "  construct_AbcBase(Abc::DataType)\n  ",
    "AlembicDataType_free": "  free_AbcBase(Abc::DataType)\n  ",
    "AlembicDataType_construct2Args": "  this_->handle = new Handle<Abc::DataType>(Abc::DataType((Abc::PlainOldDataType)abcPod, abcExtent));\n  ",
    "AlembicDataType_getPodName": "
  std::string abc_result = PODName(abcThis_.getPod());
  conv_to_String(abc_result, _result);
    ",
    "AlembicDataType_setPod": "  abcThis_.setPod((Abc::PlainOldDataType)abcPod);\n  ",
    "AlembicIArrayProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicIArrayProperty_free": "  free_AbcBasePtr(Abc::IArrayProperty)\n  ",
    "AlembicIArrayProperty_construct2Args": "
  Abc::IArrayProperty * abcProp = new Abc::IArrayProperty(*abcParent, abcName);
  this_->handle = new PtrHandle<Abc::IArrayProperty>(abcProp, true);
    ",
    "AlembicIArrayProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicIArrayProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicIArrayProperty_getAsBoolean": "  AlembicIArrayPropertyGetExport(Boolean, kBooleanPOD)\n  ",
    "AlembicIArrayProperty_getAsBooleanWithISS": "  AlembicIArrayPropertyGetWithISSExport(Boolean, kBooleanPOD)\n  ",
    "AlembicIArrayProperty_getAsUInt8": "  AlembicIArrayPropertyGetExport(UInt8, kUint8POD)\n  ",
    "AlembicIArrayProperty_getAsUInt8WithISS": "  AlembicIArrayPropertyGetWithISSExport(UInt8, kUint8POD)\n  ",
    "AlembicIArrayProperty_getAsSInt8": "  AlembicIArrayPropertyGetExport(SInt8, kInt8POD)\n  ",
    "AlembicIArrayProperty_getAsSInt8WithISS": "  AlembicIArrayPropertyGetWithISSExport(SInt8, kInt8POD)\n  ",
    "AlembicIArrayProperty_getAsUInt16": "  AlembicIArrayPropertyGetExport(UInt16, kUint16POD)\n  ",
    "AlembicIArrayProperty_getAsUInt16WithISS": "  AlembicIArrayPropertyGetWithISSExport(UInt16, kUint16POD)\n  ",
    "AlembicIArrayProperty_getAsSInt16": "  AlembicIArrayPropertyGetExport(SInt16, kInt16POD)\n  ",
    "AlembicIArrayProperty_getAsSInt16WithISS": "  AlembicIArrayPropertyGetWithISSExport(SInt16, kInt16POD)\n  ",
    "AlembicIArrayProperty_getAsUInt32": "  AlembicIArrayPropertyGetExport(UInt32, kUint32POD)\n  ",
    "AlembicIArrayProperty_getAsUInt32WithISS": "  AlembicIArrayPropertyGetWithISSExport(UInt32, kUint32POD)\n  ",
    "AlembicIArrayProperty_getAsSInt32": "  AlembicIArrayPropertyGetExport(SInt32, kInt32POD)\n  ",
    "AlembicIArrayProperty_getAsSInt32WithISS": "  AlembicIArrayPropertyGetWithISSExport(SInt32, kInt32POD)\n  ",
    "AlembicIArrayProperty_getAsSInt32": "  AlembicIArrayPropertyGetExport(SInt32, kInt32POD)\n  ",
    "AlembicIArrayProperty_getAsSInt32WithISS": "  AlembicIArrayPropertyGetWithISSExport(SInt32, kInt32POD)\n  ",
    "AlembicIArrayProperty_getAsUInt64": "  AlembicIArrayPropertyGetExport(UInt64, kUint64POD)\n  ",
    "AlembicIArrayProperty_getAsUInt64WithISS": "  AlembicIArrayPropertyGetWithISSExport(UInt64, kUint64POD)\n  ",
    "AlembicIArrayProperty_getAsSInt64": "  AlembicIArrayPropertyGetExport(SInt64, kInt64POD)\n  ",
    "AlembicIArrayProperty_getAsSInt64WithISS": "  AlembicIArrayPropertyGetWithISSExport(SInt64, kInt64POD)\n  ",
    "AlembicIArrayProperty_getAsFloat16": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIArrayProperty_getAsFloat16: DataType.pod() not kFloat16POD.\");
  AbcA::ArraySamplePtr sample;
  abcThis_->get(sample);
  if(!sample)
    return;
  if(sample->size() == 0)
    return;
  _result.resize(sample->size());
  Abc::float16_t * floats = (Abc::float16_t*)sample->getData();
  for(size_t i=0;i<sample->size();i++)
    _result[i] = floats[i];
    ",
    "AlembicIArrayProperty_getAsFloat16WithISS": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIArrayProperty_getAsFloat16: DataType.pod() not kFloat16POD.\");
  AbcA::ArraySamplePtr sample;
  abcThis_->get(sample, *abcISS);
  if(!sample)
    return;
  if(sample->size() == 0)
    return;
  _result.resize(sample->size());
  Abc::float16_t * floats = (Abc::float16_t*)sample->getData();
  for(size_t i=0;i<sample->size();i++)
    _result[i] = floats[i];
    ",
    "AlembicIArrayProperty_getAsFloat32": "  AlembicIArrayPropertyGetExport(Float32, kFloat32POD)\n  ",
    "AlembicIArrayProperty_getAsFloat32WithISS": "  AlembicIArrayPropertyGetWithISSExport(Float32, kFloat32POD)\n  ",
    "AlembicIArrayProperty_getAsFloat64": "  AlembicIArrayPropertyGetExport(Float64, kFloat64POD)\n  ",
    "AlembicIArrayProperty_getAsFloat64WithISS": "  AlembicIArrayPropertyGetWithISSExport(Float64, kFloat64POD)\n  ",
    "AlembicIArrayProperty_getAsString": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;

  AbcA::ArraySamplePtr sample;
  abcThis_->get(sample);
  if(!sample)
    return;
  if(sample->size() == 0)
    return;

  if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    _result.resize(sample->size());
    std::string * strings = (std::string*)sample->getData();
    for(size_t i=0;i<sample->size();i++)
      _result[i] = strings[i];
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    _result.resize(sample->size());
    std::wstring * wstrings = (std::wstring*)sample->getData();
    for(size_t i=0;i<sample->size();i++)
    {
      std::string s;
      for(size_t j=0;j<wstrings[i].length();j++)
        s += wstrings[i][j];
      _result[i] = s.c_str();
    }
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIArrayProperty_getAsString: DataType.pod() not kStringPOD / kWstringPOD.\");
    ",
    "AlembicIArrayProperty_getAsStringWithISS": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;

  AbcA::ArraySamplePtr sample;
  abcThis_->get(sample, *abcISS);
  if(!sample)
    return;
  if(sample->size() == 0)
    return;

  if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    _result.resize(sample->size());
    std::string * strings = (std::string*)sample->getData();
    for(size_t i=0;i<sample->size();i++)
      _result[i] = strings[i];
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    _result.resize(sample->size());
    std::wstring * wstrings = (std::wstring*)sample->getData();
    for(size_t i=0;i<sample->size();i++)
    {
      std::string s;
      for(size_t j=0;j<wstrings[i].length();j++)
        s += wstrings[i][j];
      _result[i] = s.c_str();
    } 
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIArrayProperty_getAsString: DataType.pod() not kStringPOD / kWstringPOD.\");
    ",
    "AlembicICamera_construct": "  this_->handle = NULL;\n  ",
    "AlembicICamera_free": "  free_AbcBasePtr(AbcG::ICamera)\n  ",
    "AlembicICamera_constructFromIObject": "
  AbcG::ICamera * abcThis_ = new AbcG::ICamera(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::ICamera>(abcThis_, true);
    ",
    "AlembicICamera_matches": "  return AbcG::ICamera::matches(*abcMetaData);\n  ",
    "AlembicICameraSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicICameraSchema_free": "  free_AbcBasePtr(AbcG::ICameraSchema)\n  ",
    "AlembicICameraSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicICameraSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicICameraSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicICompoundProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicICompoundProperty_free": "  free_AbcBasePtr(AbcG::ICompoundProperty)\n  ",
    "AlembicICompoundProperty_construct2Args": "
  Abc::ICompoundProperty * abcThis_ = new Abc::ICompoundProperty(*abcParent, abcName);
  this_->handle = new PtrHandle<Abc::ICompoundProperty>(abcThis_, true);
    ",
    "AlembicICompoundProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicICompoundProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicICompoundProperty_getPropertyHeader": "
  const Abc::PropertyHeader & abc_result = abcThis_->getPropertyHeader(abcPropertyIndex);
  conv_to_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>((Abc::PropertyHeader*)&abc_result, _result);
    ",
    "AlembicICompoundProperty_getPropertyHeaderByName": "
  const Abc::PropertyHeader * abc_result = abcThis_->getPropertyHeader(abcPropertyName);
  conv_to_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>((Abc::PropertyHeader *)abc_result, _result);
    ",
    "AlembicICurves_construct": "  this_->handle = NULL;\n  ",
    "AlembicICurves_free": "  free_AbcBasePtr(AbcG::ICurves)\n  ",
    "AlembicICurves_constructFromIObject": "
  AbcG::ICurves * abcThis_ = new AbcG::ICurves(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::ICurves>(abcThis_, true);
    ",
    "AlembicICurves_matches": "  return AbcG::ICurves::matches(*abcMetaData);\n  ",
    "AlembicICurvesSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicICurvesSchema_free": "  free_AbcBasePtr(AbcG::ICurvesSchema)\n  ",
    "AlembicICurvesSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getUVsParam": "
  if(!abcThis_->getUVsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::V2fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::V2fTPTraits> (abcThis_->getUVsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getNormalsParam": "
  if(!abcThis_->getNormalsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::N3fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::N3fTPTraits> (abcThis_->getNormalsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec3NfGeomParam, AbcG::ITypedGeomParam<Abc::N3fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getWidthsParam": "
  if(!abcThis_->getWidthsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::Float32TPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::Float32TPTraits> (abcThis_->getWidthsParam());
  conv_to_AbcBasePtr<KL::AlembicIFloat32GeomParam, AbcG::ITypedGeomParam<Abc::Float32TPTraits> >(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getPositionsProperty": "
  if(!abcThis_->getPositionsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getPositionsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getVelocitiesProperty": "
  if(!abcThis_->getVelocitiesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getVelocitiesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getNumVerticesProperty": "
  if(!abcThis_->getNumVerticesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getNumVerticesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getOrdersProperty": "
  if(!abcThis_->getOrdersProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getOrdersProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSchema_getKnotsProperty": "
  if(!abcThis_->getKnotsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getKnotsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicICurvesSample_free": "  free_AbcBasePtr(AbcG::ICurvesSchema::Sample)\n  ",
    "AlembicICurvesSample_getPositions": "  AlembicIExtractExternalArrayFromSample(Abc::P3fArraySamplePtr, KL::Vec3, getPositions)",
    "AlembicICurvesSample_getCurvesNumVertices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getCurvesNumVertices)",
    "AlembicICurvesSample_getVelocities": "  AlembicIExtractExternalArrayFromSample(Abc::V3fArraySamplePtr, KL::Vec3, getVelocities)",
    "AlembicICurvesSample_getKnots": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getKnots)",
    "AlembicICurvesSample_getOrders": "  AlembicIExtractExternalArrayFromSample(Abc::UcharArraySamplePtr, KL::UInt8, getOrders)",
    "AlembicIFaceSet_construct": "  this_->handle = NULL;\n  ",
    "AlembicIFaceSet_free": "  free_AbcBasePtr(AbcG::IFaceSet)\n  ",
    "AlembicIFaceSetSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicIFaceSetSchema_free": "  free_AbcBasePtr(AbcG::IFaceSetSchema)\n  ",
    "AlembicIFaceSetSample_construct": "  construct_AbcBasePtr(AbcG::IFaceSetSchema::Sample)\n  ",
    "AlembicIFaceSetSample_free": "  free_AbcBasePtr(AbcG::IFaceSetSchema::Sample)\n  ",
    "AlembicIFaceSetSample_getFaces": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getFaces)",
    "AlembicILight_construct": "  this_->handle = NULL;\n  ",
    "AlembicILight_free": "  free_AbcBasePtr(AbcG::ILight)\n  ",
    "AlembicILight_matches": "  return AbcG::ILight::matches(*abcMetaData);\n  ",
    "AlembicILight_constructFromIObject": "
  AbcG::ILight * abcThis_ = new AbcG::ILight(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::ILight>(abcThis_, true);
    ",
    "AlembicILightSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicILightSchema_free": "  free_AbcBasePtr(AbcG::ILightSchema)\n  ",
    "AlembicILightSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicILightSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicILightSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatch_free": "  free_AbcBasePtr(AbcG::INuPatch)\n  ",
    "AlembicINuPatch_matches": "  return AbcG::INuPatch::matches(*abcMetaData);\n  ",
    "AlembicINuPatch_constructFromIObject": "
  AbcG::INuPatch * abcThis_ = new AbcG::INuPatch(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::INuPatch>(abcThis_, true);
    ",
    "AlembicINuPatchSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicINuPatchSchema_free": "  free_AbcBasePtr(AbcG::INuPatchSchema)\n  ",
    "AlembicINuPatchSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getPositionsProperty": "
  if(!abcThis_->getPositionsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getPositionsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getUKnotsProperty": "
  if(!abcThis_->getUKnotsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getUKnotsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getVKnotsProperty": "
  if(!abcThis_->getVKnotsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getVKnotsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getVelocitiesProperty": "
  if(!abcThis_->getVelocitiesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getVelocitiesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getPositionWeightsProperty": "
  if(!abcThis_->getPositionWeightsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getPositionWeightsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getUVsParam": "
  if(!abcThis_->getUVsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::V2fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::V2fTPTraits> (abcThis_->getUVsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicINuPatchSchema_getNormalsParam": "
  if(!abcThis_->getNormalsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::N3fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::N3fTPTraits> (abcThis_->getNormalsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec3NfGeomParam, AbcG::ITypedGeomParam<Abc::N3fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicINuPatchSample_free": "  free_AbcBasePtr(AbcG::INuPatchSchema::Sample)\n  ",
    "AlembicINuPatchSample_getPositions": "  AlembicIExtractExternalArrayFromSample(Abc::P3fArraySamplePtr, KL::Vec3, getPositions)",
    "AlembicINuPatchSample_getPositionWeights": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getPositionWeights)",
    "AlembicINuPatchSample_getUKnot": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getUKnot)",
    "AlembicINuPatchSample_getVKnot": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getVKnot)",
    "AlembicINuPatchSample_getVelocities": "  AlembicIExtractExternalArrayFromSample(Abc::V3fArraySamplePtr, KL::Vec3, getVelocities)",
    "AlembicINuPatchSample_getTrimNumCurves": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getTrimNumCurves)",
    "AlembicINuPatchSample_getTrimNumVertices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getTrimNumVertices)",
    "AlembicINuPatchSample_getTrimOrders": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getTrimOrders)",
    "AlembicINuPatchSample_getTrimKnots": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimKnots)",
    "AlembicINuPatchSample_getTrimMins": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimMins)",
    "AlembicINuPatchSample_getTrimMaxes": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimMaxes)",
    "AlembicINuPatchSample_getTrimU": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimU)",
    "AlembicINuPatchSample_getTrimV": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimV)",
    "AlembicINuPatchSample_getTrimW": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getTrimW)",
    "AlembicIObject_construct": "  this_->handle = NULL;\n  ",
    "AlembicIObject_free": "  free_AbcBasePtr(Abc::IObject)\n  ",
    "AlembicIObject_getMetaData": "  AlembicGetMetaData()",
    "AlembicIObject_constructFromIXform": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcXform, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromICamera": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcCamera, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromILight": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcLight, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromIPoints": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcPoints, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromIPolyMesh": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcPolyMesh, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromICurves": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcCurves, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromINuPatch": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcPatch, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIObject_constructFromISubD": "
  Abc::IObject * abcThis_ = new Abc::IObject(*abcSubd, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::IObject>(abcThis_, true);
    ",
    "AlembicIPoints_construct": "  this_->handle = NULL;\n  ",
    "AlembicIPoints_free": "  free_AbcBasePtr(AbcG::IPoints)\n  ",
    "AlembicIPoints_matches": "  return AbcG::IPoints::matches(*abcMetaData);\n  ",
    "AlembicIPoints_constructFromIObject": "
  AbcG::IPoints * abcThis_ = new AbcG::IPoints(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::IPoints>(abcThis_, true);
    ",
    "AlembicIPointsSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicIPointsSchema_free": "  free_AbcBasePtr(AbcG::IPointsSchema)\n  ",
    "AlembicIPointsSample_construct": "  construct_AbcBasePtr(AbcG::IPointsSchema::Sample)\n  ",
    "AlembicIPointsSample_free": "  free_AbcBasePtr(AbcG::IPointsSchema::Sample)\n  ",
    "AlembicIPointsSample_getPositions": "  AlembicIExtractExternalArrayFromSample(Abc::P3fArraySamplePtr, KL::Vec3, getPositions)",
    "AlembicIPointsSample_getIds": "  AlembicIExtractExternalArrayFromSample(Abc::UInt64ArraySamplePtr, KL::UInt64, getIds)",
    "AlembicIPointsSample_getVelocities": "  AlembicIExtractExternalArrayFromSample(Abc::V3fArraySamplePtr, KL::Vec3, getVelocities)",
    "AlembicIPolyMesh_construct": "  this_->handle = NULL;\n  ",
    "AlembicIPolyMesh_free": "  free_AbcBasePtr(AbcG::IPolyMesh)\n  ",
    "AlembicIPolyMesh_matches": "  return AbcG::IPolyMesh::matches(*abcMetaData);\n  ",
    "AlembicIPolyMesh_constructFromIObject": "
  AbcG::IPolyMesh * abcThis_ = new AbcG::IPolyMesh(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::IPolyMesh>(abcThis_, true);
    ",
    "AlembicIPolyMeshSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicIPolyMeshSchema_free": "  free_AbcBasePtr(AbcG::IPolyMeshSchema)\n  ",
    "AlembicIPolyMeshSchema_getFaceSetNames": "
  std::vector<std::string> abc_result;
  abcThis_->getFaceSetNames(abc_result);
  _result.resize(abc_result.size());
  for(size_t i=0;i<abc_result.size();i++)
    _result[i] = abc_result[i].c_str();
    ",
    "AlembicIPolyMeshSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getUVsParam": "
  if(!abcThis_->getUVsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::V2fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::V2fTPTraits> (abcThis_->getUVsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getNormalsParam": "
  if(!abcThis_->getNormalsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::N3fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::N3fTPTraits> (abcThis_->getNormalsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec3NfGeomParam, AbcG::ITypedGeomParam<Abc::N3fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getFaceCountsProperty": "
  if(!abcThis_->getFaceCountsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getFaceCountsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getFaceIndicesProperty": "
  if(!abcThis_->getFaceIndicesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getFaceIndicesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getPositionsProperty": "
  if(!abcThis_->getPositionsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getPositionsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSchema_getVelocitiesProperty": "
  if(!abcThis_->getVelocitiesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getVelocitiesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicIPolyMeshSample_free": "  free_AbcBasePtr(AbcG::IPolyMeshSchema::Sample)\n  ",
    "AlembicIPolyMeshSample_getPositions": "  AlembicIExtractExternalArrayFromSample(Abc::P3fArraySamplePtr, KL::Vec3, getPositions)",
    "AlembicIPolyMeshSample_getVelocities": "  AlembicIExtractExternalArrayFromSample(Abc::V3fArraySamplePtr, KL::Vec3, getVelocities)",
    "AlembicIPolyMeshSample_getFaceIndices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getFaceIndices)",
    "AlembicIPolyMeshSample_getFaceCounts": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getFaceCounts)",
    "AlembicIScalarProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicIScalarProperty_free": "  free_AbcBasePtr(Abc::IScalarProperty)\n  ",
    "AlembicIScalarProperty_construct2Args": "
  Abc::IScalarProperty * abcThis_ = new Abc::IScalarProperty(*abcParent, abcName);
  this_->handle = new PtrHandle<Abc::IScalarProperty>(abcThis_, true);
    ",
    "AlembicIScalarProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicIScalarProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicIScalarProperty_getAsBoolean": "  AlembicIScalarPropertyGetExport(Boolean, kBooleanPOD)",
    "AlembicIScalarProperty_getAsBooleanWithISS": "  AlembicIScalarPropertyGetExportWithISS(Boolean, kBooleanPOD)",
    "AlembicIScalarProperty_getAsUInt8": "  AlembicIScalarPropertyGetExport(UInt8, kUint8POD)",
    "AlembicIScalarProperty_getAsUInt8WithISS": "  AlembicIScalarPropertyGetExportWithISS(UInt8, kUint8POD)",
    "AlembicIScalarProperty_getAsSInt8": "  AlembicIScalarPropertyGetExport(SInt8, kInt8POD)",
    "AlembicIScalarProperty_getAsSInt8WithISS": "  AlembicIScalarPropertyGetExportWithISS(SInt8, kInt8POD)",
    "AlembicIScalarProperty_getAsUInt16": "  AlembicIScalarPropertyGetExport(UInt16, kUint16POD)",
    "AlembicIScalarProperty_getAsUInt16WithISS": "  AlembicIScalarPropertyGetExportWithISS(UInt16, kUint16POD)",
    "AlembicIScalarProperty_getAsSInt16": "  AlembicIScalarPropertyGetExport(SInt16, kInt16POD)",
    "AlembicIScalarProperty_getAsSInt16WithISS": "  AlembicIScalarPropertyGetExportWithISS(SInt16, kInt16POD)",
    "AlembicIScalarProperty_getAsUInt32": "  AlembicIScalarPropertyGetExport(UInt32, kUint32POD)",
    "AlembicIScalarProperty_getAsUInt32WithISS": "  AlembicIScalarPropertyGetExportWithISS(UInt32, kUint32POD)",
    "AlembicIScalarProperty_getAsSInt32": "  AlembicIScalarPropertyGetExport(SInt32, kInt32POD)",
    "AlembicIScalarProperty_getAsSInt32WithISS": "  AlembicIScalarPropertyGetExportWithISS(SInt32, kInt32POD)",
    "AlembicIScalarProperty_getAsUInt64": "  AlembicIScalarPropertyGetExport(UInt64, kUint64POD)",
    "AlembicIScalarProperty_getAsUInt64WithISS": "  AlembicIScalarPropertyGetExportWithISS(UInt64, kUint64POD)",
    "AlembicIScalarProperty_getAsSInt64": "  AlembicIScalarPropertyGetExport(SInt64, kInt64POD)",
    "AlembicIScalarProperty_getAsSInt64WithISS": "  AlembicIScalarPropertyGetExportWithISS(SInt64, kInt64POD)",
    "AlembicIScalarProperty_getAsFloat16": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIScalarProperty_getAsFloat16: DataType.pod() not kFloat16POD.\");

  std::vector<Abc::float16_t> floats(header.getDataType().getExtent());
  _result.resize(floats.size());
  abcThis_->get(&floats[0]);
  for(size_t i=0;i<floats.size();i++)
    _result[i] = floats[i];
    ",
    "AlembicIScalarProperty_getAsFloat16WithISS": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIScalarProperty_getAsFloat16: DataType.pod() not kFloat16POD.\");

  std::vector<Abc::float16_t> floats(header.getDataType().getExtent());
  _result.resize(floats.size());
  abcThis_->get(&floats[0], *abcISS);
  for(size_t i=0;i<floats.size();i++)
    _result[i] = floats[i];
    ",
    "AlembicIScalarProperty_getAsFloat32": "  AlembicIScalarPropertyGetExport(Float32, kFloat32POD)",
    "AlembicIScalarProperty_getAsFloat32WithISS": "  AlembicIScalarPropertyGetExportWithISS(Float32, kFloat32POD)",
    "AlembicIScalarProperty_getAsFloat64": "  AlembicIScalarPropertyGetExport(Float64, kFloat64POD)",
    "AlembicIScalarProperty_getAsFloat64WithISS": "  AlembicIScalarPropertyGetExportWithISS(Float64, kFloat64POD)",
    "AlembicIScalarProperty_getAsString": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    std::vector<std::string> strings(header.getDataType().getExtent());
    _result.resize(strings.size());
    abcThis_->get(&strings[0]);
    for(size_t i=0;i<strings.size();i++)
      _result[i] = strings[i].c_str();
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    std::vector<std::wstring> wstrings(header.getDataType().getExtent());
    _result.resize(wstrings.size());
    abcThis_->get(&wstrings[0]);
    for(size_t i=0;i<wstrings.size();i++)
    {
      std::string s;
      for(size_t j=0;j<wstrings[i].length();j++)
        s += wstrings[i][j];
      _result[i] = s.c_str();
    }
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIScalarProperty_getAsString: DataType.pod() not kStringPOD / kWstringPOD.\");
    ",
    "AlembicIScalarProperty_getAsStringWithISS": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    std::vector<std::string> strings(header.getDataType().getExtent());
    _result.resize(strings.size());
    abcThis_->get(&strings[0], *abcISS);
    for(size_t i=0;i<strings.size();i++)
      _result[i] = strings[i].c_str();
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    std::vector<std::wstring> wstrings(header.getDataType().getExtent());
    _result.resize(wstrings.size());
    abcThis_->get(&wstrings[0], *abcISS);
    for(size_t i=0;i<wstrings.size();i++)
    {
      std::string s;
      for(size_t j=0;j<wstrings[i].length();j++)
        s += wstrings[i][j];
      _result[i] = s.c_str();
    }
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicIScalarProperty_getAsString: DataType.pod() not kStringPOD / kWstringPOD.\");
    ",
    "AlembicISubD_construct": "  this_->handle = NULL;\n  ",
    "AlembicISubD_free": "  free_AbcBasePtr(AbcG::ISubD)\n  ",
    "AlembicISubD_matches": "  return AbcG::ISubD::matches(*abcMetaData);\n  ",
    "AlembicISubD_constructFromIObject": "
  AbcG::ISubD * abcThis_ = new AbcG::ISubD(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::ISubD>(abcThis_, true);
    ",
    "AlembicISubDSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicISubDSchema_free": "  free_AbcBasePtr(AbcG::ISubDSchema)\n  ",
    "AlembicISubDSchema_getFaceSetNames": "
  std::vector<std::string> abc_result;
  abcThis_->getFaceSetNames(abc_result);
  _result.resize(abc_result.size());
  for(size_t i=0;i<abc_result.size();i++)
    _result[i] = abc_result[i].c_str();
    ",
    "AlembicISubDSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getUVsParam": "
  if(!abcThis_->getUVsParam().valid())
    return;
  AbcG::ITypedGeomParam<Abc::V2fTPTraits> * abc_result = new AbcG::ITypedGeomParam<Abc::V2fTPTraits> (abcThis_->getUVsParam());
  conv_to_AbcBasePtr<KL::AlembicIVec2VfGeomParam, AbcG::ITypedGeomParam<Abc::V2fTPTraits> >(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getFaceCountsProperty": "
  if(!abcThis_->getFaceCountsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getFaceCountsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getFaceIndicesProperty": "
  if(!abcThis_->getFaceIndicesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getFaceIndicesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getPositionsProperty": "
  if(!abcThis_->getPositionsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getPositionsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getVelocitiesProperty": "
  if(!abcThis_->getVelocitiesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getVelocitiesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getFaceVaryingInterpolateBoundaryProperty": "
  if(!abcThis_->getFaceVaryingInterpolateBoundaryProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getFaceVaryingInterpolateBoundaryProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getFaceVaryingPropagateCornersProperty": "
  if(!abcThis_->getFaceVaryingPropagateCornersProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getFaceVaryingPropagateCornersProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getInterpolateBoundaryProperty": "
  if(!abcThis_->getInterpolateBoundaryProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getInterpolateBoundaryProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getCreaseIndicesProperty": "
  if(!abcThis_->getCreaseIndicesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getCreaseIndicesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getCreaseLengthsProperty": "
  if(!abcThis_->getCreaseLengthsProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getCreaseLengthsProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getCreaseSharpnessesProperty": "
  if(!abcThis_->getCreaseSharpnessesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getCreaseSharpnessesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getCornerIndicesProperty": "
  if(!abcThis_->getCornerIndicesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getCornerIndicesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getCornerSharpnessesProperty": "
  if(!abcThis_->getCornerSharpnessesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getCornerSharpnessesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getHolesProperty": "
  if(!abcThis_->getHolesProperty().valid())
    return;
  Abc::IArrayProperty* abc_result = new Abc::IArrayProperty(abcThis_->getHolesProperty());
  conv_to_AbcBasePtr<KL::AlembicIArrayProperty, Abc::IArrayProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSchema_getSubdivisionSchemeProperty": "
  if(!abcThis_->getSubdivisionSchemeProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getSubdivisionSchemeProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicISubDSample_free": "  free_AbcBasePtr(AbcG::ISubDSchema::Sample)\n  ",
    "AlembicISubDSample_getPositions": "  AlembicIExtractExternalArrayFromSample(Abc::P3fArraySamplePtr, KL::Vec3, getPositions)",
    "AlembicISubDSample_getVelocities": "  AlembicIExtractExternalArrayFromSample(Abc::V3fArraySamplePtr, KL::Vec3, getVelocities)",
    "AlembicISubDSample_getFaceIndices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getFaceIndices)",
    "AlembicISubDSample_getFaceCounts": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getFaceCounts)",
    "AlembicISubDSample_getCreaseIndices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getCreaseIndices)",
    "AlembicISubDSample_getCreaseLengths": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getCreaseLengths)",
    "AlembicISubDSample_getCreaseSharpnesses": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getCreaseSharpnesses)",
    "AlembicISubDSample_getCornerIndices": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getCornerIndices)",
    "AlembicISubDSample_getCornerSharpnesses": "  AlembicIExtractExternalArrayFromSample(Abc::FloatArraySamplePtr, KL::Float32, getCornerSharpnesses)",
    "AlembicISubDSample_getHoles": "  AlembicIExtractExternalArrayFromSample(Abc::Int32ArraySamplePtr, KL::SInt32, getHoles)",
    "AlembicIXform_construct": "  this_->handle = NULL;\n  ",
    "AlembicIXform_free": "  free_AbcBasePtr(AbcG::IXform)\n  ",
    "AlembicIXform_matches": "  return AbcG::IXform::matches(*abcMetaData);\n  ",
    "AlembicIXform_constructFromIObject": "
  AbcG::IXform * abcThis_ = new AbcG::IXform(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::IXform>(abcThis_, true);
    ",
    "AlembicIXformSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicIXformSchema_free": "  free_AbcBasePtr(AbcG::IXformSchema)\n  ",
    "AlembicIXformSchema_getArbGeomParams": "
  if(!abcThis_->getArbGeomParams().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getArbGeomParams());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicIXformSchema_getUserProperties": "
  if(!abcThis_->getUserProperties().valid())
    return;
  Abc::ICompoundProperty* abc_result = new Abc::ICompoundProperty(abcThis_->getUserProperties());
  conv_to_AbcBasePtr<KL::AlembicICompoundProperty, Abc::ICompoundProperty>(abc_result, _result, true);
    ",
    "AlembicIXformSchema_getChildBoundsProperty": "
  if(!abcThis_->getChildBoundsProperty().valid())
    return;
  Abc::IScalarProperty* abc_result = new Abc::IScalarProperty(abcThis_->getChildBoundsProperty());
  conv_to_AbcBasePtr<KL::AlembicIScalarProperty, Abc::IScalarProperty>(abc_result, _result, true);
    ",
    "AlembicXformSample_free": "  free_AbcBasePtr(AbcG::XformSample)\n  ",
    "AlembicXformSample_isTopologyEqual": "  return abcThis_->isTopologyEqual(*abcOtherSample);\n  ",

    "AlembicMetaData_construct": "  construct_AbcBasePtr(AbcG::MetaData)\n  ",
    "AlembicMetaData_free": "  free_AbcBasePtr(AbcG::MetaData)\n  ",
    "AlembicMetaData_keys": "
  _result.resize(abcThis_->size());
  uint32_t offset = 0;
  for(Abc::MetaData::const_iterator it=abcThis_->begin();it!=abcThis_->end();it++)
    _result[offset++] = it->first.c_str();
    ",
    "AlembicMetaData_append": "  abcThis_->append(*abcMetaData);\n  ",
    "AlembicMetaData_appendUnique": "  abcThis_->appendUnique(*abcMetaData);\n  ",
    "AlembicMetaData_matches": "  return abcThis_->matches(*abcMetaData);\n  ",
    "AlembicMetaData_matchesOverlap": "  return abcThis_->matchesOverlap(*abcMetaData);\n  ",
    "AlembicMetaData_matchesExactly": "  return abcThis_->matchesExactly(*abcMetaData);\n  ",
    "AlembicOArchive_construct": "  this_->handle = NULL;\n  ",
    "AlembicOArchive_free": "  free_AbcBasePtr(Abc::OArchive)\n  ",
    "AlembicOArchive_constructFrom2Args": "
  if(abcCoreType.length() == 0)
  {
    setError(\"AlembicOArchive_constructFrom2Args: No coreType specified.\");
    return;
  }
  if(abcFileName.length() == 0)
  {
    setError(\"AlembicOArchive_constructFrom2Args: No fileName specified.\");
    return;
  }
  Abc::OArchive * abcArchive;
  if(abcCoreType == \"HDF5\")
    abcArchive = new Abc::OArchive(AbcH::WriteArchive(), abcFileName);
  else if(abcCoreType == \"Ogawa\")
    abcArchive = new Abc::OArchive(AbcO::WriteArchive(), abcFileName);
  else
  {
    setError(\"AlembicOArchive_constructFrom2Args coreType '%s', only 'HDF5' and 'Ogawa' supported.\", abcCoreType.c_str());
    return;
  }

  this_->handle = new PtrHandle<Abc::OArchive>(abcArchive, true);
    ",
    "AlembicOArchive_addTimeSampling": "  return abcThis_->addTimeSampling(*abcTimeSampling);",
    "AlembicOArrayProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicOArrayProperty_free": "  free_AbcBasePtr(Abc::OArrayProperty)\n  ",
    "AlembicOArrayProperty_construct3Args": "
  Abc::OArrayProperty * abcThis_ = new Abc::OArrayProperty(*abcParent, abcName, abcDataType);
  this_->handle = new PtrHandle<Abc::OArrayProperty>(abcThis_, true);
    ",
    "AlembicOArrayProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicOArrayProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicOArrayProperty_setAsBoolean": "  AlembicOArrayPropertySetExport(Boolean, kBooleanPOD)\n  ",
    "AlembicOArrayProperty_setAsUInt8": "  AlembicOArrayPropertySetExport(UInt8, kUint8POD)\n  ",
    "AlembicOArrayProperty_setAsSInt8": "  AlembicOArrayPropertySetExport(SInt8, kInt8POD)\n  ",
    "AlembicOArrayProperty_setAsUInt16": "  AlembicOArrayPropertySetExport(UInt16, kUint16POD)\n  ",
    "AlembicOArrayProperty_setAsSInt16": "  AlembicOArrayPropertySetExport(SInt16, kInt16POD)\n  ",
    "AlembicOArrayProperty_setAsUInt32": "  AlembicOArrayPropertySetExport(UInt32, kUint32POD)\n  ",
    "AlembicOArrayProperty_setAsSInt32": "  AlembicOArrayPropertySetExport(SInt32, kInt32POD)\n  ",
    "AlembicOArrayProperty_setAsSInt32": "  AlembicOArrayPropertySetExport(SInt32, kInt32POD)\n  ",
    "AlembicOArrayProperty_setAsUInt64": "  AlembicOArrayPropertySetExport(UInt64, kUint64POD)\n  ",
    "AlembicOArrayProperty_setAsSInt64": "  AlembicOArrayPropertySetExport(SInt64, kInt64POD)\n  ",
    "AlembicOArrayProperty_setAsFloat16": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicOArrayProperty_setAsFloat16: DataType.pod() not kFloat16POD.\");
  if(values.size() == 0)
    abcThis_->set(Abc::ArraySample());
  else
    abcThis_->set(Abc::ArraySample(&values[0], header.getDataType(), AbcU::Dimensions(values.size())));
    ",
    "AlembicOArrayProperty_setAsFloat32": "  AlembicOArrayPropertySetExport(Float32, kFloat32POD)\n  ",
    "AlembicOArrayProperty_setAsFloat64": "  AlembicOArrayPropertySetExport(Float64, kFloat64POD)\n  ",
    "AlembicOArrayProperty_setAsString": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(values.size() == 0)
    abcThis_->set(Abc::ArraySample());
  else if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    std::vector<std::string> strings(values.size());
    for(size_t i=0;i<strings.size();i++)
      strings[i] = values[i].data();
    abcThis_->set(Abc::ArraySample(&strings[0], header.getDataType(), AbcU::Dimensions(strings.size())));
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    std::vector<std::wstring> wstrings(values.size());
    for(size_t i=0;i<wstrings.size();i++)
    {
      std::string s = values[i].data();
      for(size_t j=0;j<s.length();j++)
        wstrings[i] += s[j];
    }
    abcThis_->set(Abc::ArraySample(&wstrings[0], header.getDataType(), AbcU::Dimensions(wstrings.size())));
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicOArrayProperty_setAsString: DataType.pod() not kStringPOD.\");
    ",
    "AlembicOCamera_construct": "  this_->handle = NULL;\n  ",
    "AlembicOCamera_free": "  free_AbcBasePtr(AbcG::OCamera)\n  ",
    "AlembicOCamera_construct3Args": "
  AbcG::OCamera * abcThis_ = new AbcG::OCamera(*abcParent, abcName, abcTimeSampling);
  this_->handle = new PtrHandle<AbcG::OCamera>(abcThis_, true);
    ",
    "AlembicOCamera_matches": "  return AbcG::OCamera::matches(*abcMetaData);\n  ",
    "AlembicOCameraSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOCameraSchema_free": "  free_AbcBasePtr(AbcG::OCameraSchema)\n  ",
    "AlembicOCompoundProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicOCompoundProperty_free": "  free_AbcBasePtr(AbcG::OCompoundProperty)\n  ",
    "AlembicOCompoundProperty_construct2Args": "
  Abc::OCompoundProperty * abcThis_ = new Abc::OCompoundProperty(*abcParent, abcName);
  this_->handle = new PtrHandle<Abc::OCompoundProperty>(abcThis_, true);
    ",
    "AlembicOCompoundProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicOCompoundProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicOCompoundProperty_getPropertyHeader": "
  Abc::PropertyHeader abc_result = abcThis_->getPropertyHeader(abcPropertyIndex);
  conv_to_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>(&abc_result, _result);
    ",
    "AlembicOCompoundProperty_getPropertyHeaderByName": "
  const Abc::PropertyHeader * abc_result = abcThis_->getPropertyHeader(abcPropertyName);
  conv_to_AbcBasePtr<KL::AlembicPropertyHeader, Abc::PropertyHeader>((Abc::PropertyHeader *)abc_result, _result);
    ",
    "AlembicOCurves_construct": "  this_->handle = NULL;\n  ",
    "AlembicOCurves_free": "  free_AbcBasePtr(AbcG::OCurves)\n  ",
    "AlembicOCurves_construct3Args": "
  AbcG::OCurves * abcThis_ = new AbcG::OCurves(*abcParent, abcName, abcTimeSampling);
  this_->handle = new PtrHandle<AbcG::OCurves>(abcThis_, true);
    ",
    "AlembicOCurves_matches": "  return AbcG::OCurves::matches(*abcMetaData);\n  ",
    "AlembicOCurvesSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOCurvesSchema_free": "  free_AbcBasePtr(AbcG::OCurvesSchema)\n  ",
    "AlembicOCurvesSample_construct": "  construct_AbcBasePtr(AbcG::OCurvesSchema::Sample)\n  ",
    "AlembicOCurvesSample_free": "  free_AbcBasePtr(AbcG::OCurvesSchema::Sample)\n  ",
    "AlembicOCurvesSample_getPositions": "  AlembicOExtractExternalArrayFromSample(Abc::P3fArraySample, KL::Vec3, getPositions)",
    "AlembicOCurvesSample_setPositions": "  AlembicPackExternalArrayToSample(Abc::P3fArraySample, Abc::V3f, setPositions)",
    "AlembicOCurvesSample_getCurvesNumVertices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getCurvesNumVertices)",
    "AlembicOCurvesSample_setCurvesNumVertices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setCurvesNumVertices)",
    "AlembicOCurvesSample_getVelocities": "  AlembicOExtractExternalArrayFromSample(Abc::V3fArraySample, KL::Vec3, getVelocities)",
    "AlembicOCurvesSample_setVelocities": "  AlembicPackExternalArrayToSample(Abc::V3fArraySample, Abc::V3f, setVelocities)",
    "AlembicOCurvesSample_getKnots": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getKnots)",
    "AlembicOCurvesSample_setKnots": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, Abc::float32_t, setKnots)",
    "AlembicOCurvesSample_getOrders": "  AlembicOExtractExternalArrayFromSample(Abc::UcharArraySample, KL::UInt8, getOrders)",
    "AlembicOCurvesSample_setOrders": "  AlembicPackExternalArrayToSample(Abc::UcharArraySample, Abc::uint8_t, setOrders)",
    "AlembicOCurvesSample_setType": "  abcThis_->setType((AbcG::CurveType)abcCurveType);\n  ",
    "AlembicOCurvesSample_setWrap": "  abcThis_->setWrap((AbcG::CurvePeriodicity)abcWrap);\n  ",
    "AlembicOCurvesSample_setBasis": "  abcThis_->setBasis((AbcG::BasisType)abcBasis);\n  ",
    "AlembicOCurvesSample_getWidths": "
  AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample(abcThis_->getWidths());
  conv_to_AbcBasePtr<KL::AlembicOFloat32GeomParamSample, AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOCurvesSample_getUVs": "
  AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample(abcThis_->getUVs());
  conv_to_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOCurvesSample_getNormals": "
  AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample(abcThis_->getNormals());
  conv_to_AbcBasePtr<KL::AlembicOVec3NfGeomParamSample, AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOFaceSet_construct": "  this_->handle = NULL;\n  ",
    "AlembicOFaceSet_free": "  free_AbcBasePtr(AbcG::OFaceSet)\n  ",
    "AlembicOFaceSetSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOFaceSetSchema_free": "  free_AbcBasePtr(AbcG::OFaceSetSchema)\n  ",
    "AlembicOFaceSetSchema_setFaceExclusivity": "  abcThis_->setFaceExclusivity((AbcG::FaceSetExclusivity)abcFacesExclusive);\n",
    "AlembicOFaceSetSample_construct": "  construct_AbcBasePtr(AbcG::OFaceSetSchema::Sample)\n  ",
    "AlembicOFaceSetSample_free": "  free_AbcBasePtr(AbcG::OFaceSetSchema::Sample)\n  ",
    "AlembicOFaceSetSample_constructFromFaces": "
  Abc::TypedArraySample<Abc::Int32TPTraits> abcFaces;
  if(faces.size() > 0)
    abcFaces = Abc::TypedArraySample<Abc::Int32TPTraits>((const Abc::int32_t *)&faces[0], faces.size());
  this_->handle = new PtrHandle<AbcG::OFaceSetSchema::Sample>(new AbcG::OFaceSetSchema::Sample(abcFaces), true);
    ",
    "AlembicOFaceSetSample_getFaces": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getFaces)",
    "AlembicOFaceSetSample_setFaces": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setFaces)",
    "AlembicOLight_construct": "  this_->handle = NULL;\n  ",
    "AlembicOLight_free": "  free_AbcBasePtr(AbcG::OLight)\n  ",
    "AlembicOLight_construct3Args": "
  AbcG::OLight * abcThis_ = new AbcG::OLight(*abcParent, abcName, abcTimeSampling);
  this_->handle = new PtrHandle<AbcG::OLight>(abcThis_, true);
    ",
    "AlembicOLight_matches": "  return AbcG::OLight::matches(*abcMetaData);\n  ",
    "AlembicOLightSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOLightSchema_free": "  free_AbcBasePtr(AbcG::OLightSchema)\n  ",
    "AlembicONuPatch_construct": "  this_->handle = NULL;\n  ",
    "AlembicONuPatch_free": "  free_AbcBasePtr(AbcG::ONuPatch)\n  ",
    "AlembicONuPatch_matches": "  return AbcG::ONuPatch::matches(*abcMetaData);\n  ",
    "AlembicONuPatch_construct3Args": "
  AbcG::ONuPatch * abcThis_ = new AbcG::ONuPatch(*abcParent, abcName, abcTimeSampling);
  this_->handle = new PtrHandle<AbcG::ONuPatch>(abcThis_, true);
    ",
    "AlembicONuPatchSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicONuPatchSchema_free": "  free_AbcBasePtr(AbcG::ONuPatchSchema)\n  ",
    "AlembicONuPatchSample_construct": "  construct_AbcBasePtr(AbcG::ONuPatchSchema::Sample)\n  ",
    "AlembicONuPatchSample_free": "  free_AbcBasePtr(AbcG::ONuPatchSchema::Sample)\n  ",
    "AlembicONuPatchSample_getPositions": "  AlembicOExtractExternalArrayFromSample(Abc::P3fArraySample, KL::Vec3, getPositions)",
    "AlembicONuPatchSample_setPositions": "  AlembicPackExternalArrayToSample(Abc::P3fArraySample, Abc::V3f, setPositions)",
    "AlembicONuPatchSample_getPositionWeights": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getPositionWeights)",
    "AlembicONuPatchSample_setPositionWeights": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, Abc::float32_t, setPositionWeights)",
    "AlembicONuPatchSample_getUKnot": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getUKnot)",
    "AlembicONuPatchSample_setUKnot": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, Abc::float32_t, setUKnot)",
    "AlembicONuPatchSample_getVKnot": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getVKnot)",
    "AlembicONuPatchSample_setVKnot": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, Abc::float32_t, setVKnot)",
    "AlembicONuPatchSample_getVelocities": "  AlembicOExtractExternalArrayFromSample(Abc::V3fArraySample, KL::Vec3, getVelocities)",
    "AlembicONuPatchSample_setVelocities": "  AlembicPackExternalArrayToSample(Abc::V3fArraySample, Abc::V3f, setVelocities)",
    "AlembicONuPatchSample_getTrimNumCurves": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getTrimNumCurves)",
    "AlembicONuPatchSample_setTrimNumCurves": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setTrimNumCurves)",
    "AlembicONuPatchSample_getTrimNumVertices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getTrimNumVertices)",
    "AlembicONuPatchSample_setTrimNumVertices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setTrimNumVertices)",
    "AlembicONuPatchSample_getTrimOrder": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getTrimOrder)",
    "AlembicONuPatchSample_getTrimKnot": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimKnot)",
    "AlembicONuPatchSample_getTrimMin": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimMin)",
    "AlembicONuPatchSample_getTrimMax": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimMax)",
    "AlembicONuPatchSample_getTrimU": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimU)",
    "AlembicONuPatchSample_getTrimV": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimV)",
    "AlembicONuPatchSample_getTrimW": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getTrimW)",
    "AlembicONuPatchSample_setTrimCurve": "
  Abc::Int32ArraySample nCurvesSample;
  if(nCurves.size() > 0)
    nCurvesSample = Abc::Int32ArraySample((const Abc::int32_t *)&nCurves[0], nCurves.size());
  Abc::Int32ArraySample nSample;
  if(n.size() > 0)
    nSample = Abc::Int32ArraySample((const Abc::int32_t *)&n[0], n.size());
  Abc::Int32ArraySample orderSample;
  if(order.size() > 0)
    orderSample = Abc::Int32ArraySample((const Abc::int32_t *)&order[0], order.size());
  Abc::FloatArraySample knotSample;
  if(knot.size() > 0)
    knotSample = Abc::FloatArraySample((const Abc::float32_t *)&knot[0], knot.size());
  Abc::FloatArraySample minSample;
  if(min.size() > 0)
    minSample = Abc::FloatArraySample((const Abc::float32_t *)&min[0], min.size());
  Abc::FloatArraySample maxSample;
  if(max.size() > 0)
    maxSample = Abc::FloatArraySample((const Abc::float32_t *)&max[0], max.size());
  Abc::FloatArraySample uSample;
  if(u.size() > 0)
    uSample = Abc::FloatArraySample((const Abc::float32_t *)&u[0], u.size());
  Abc::FloatArraySample vSample;
  if(v.size() > 0)
    vSample = Abc::FloatArraySample((const Abc::float32_t *)&v[0], v.size());
  Abc::FloatArraySample wSample;
  if(w.size() > 0)
    wSample = Abc::FloatArraySample((const Abc::float32_t *)&w[0], w.size());

  abcThis_->setTrimCurve(nLoops, nCurvesSample, nSample, orderSample, knotSample, minSample, maxSample, uSample, vSample, wSample);
    ",
    "AlembicONuPatchSample_getUVs": "
  AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample(abcThis_->getUVs());
  conv_to_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicONuPatchSample_getNormals": "
  AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample(abcThis_->getNormals());
  conv_to_AbcBasePtr<KL::AlembicOVec3NfGeomParamSample, AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOObject_construct": "  this_->handle = NULL;\n  ",
    "AlembicOObject_free": "  free_AbcBasePtr(Abc::OObject)\n  ",
    "AlembicOObject_getMetaData": "  AlembicGetMetaData()",
    "AlembicOObject_constructFrom2Args": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcParent, abcName);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOXform": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcXform, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOCamera": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcCamera, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOLight": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcLight, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOPoints": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcPoints, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOPolyMesh": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcPolyMesh, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOCurves": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcCurves, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromONuPatch": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcPatch, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOObject_constructFromOSubD": "
  Abc::OObject * abcThis_ = new Abc::OObject(*abcSubd, Abc::kWrapExisting);
  this_->handle = new PtrHandle<Abc::OObject>(abcThis_, true);
    ",
    "AlembicOPoints_construct": "  this_->handle = NULL;\n  ",
    "AlembicOPoints_free": "  free_AbcBasePtr(AbcG::OPoints)\n  ",
    "AlembicOPoints_matches": "  return AbcG::OPoints::matches(*abcMetaData);\n  ",
    "AlembicOPoints_constructFromOObject": "
  AbcG::OPoints * abcThis_ = new AbcG::OPoints(*abcObj, Abc::kWrapExisting);
  this_->handle = new PtrHandle<AbcG::OPoints>(abcThis_, true);
    ",
    "AlembicOPoints_construct3Args": "
  AbcG::OPoints * abcThis_ = new AbcG::OPoints(*abcParent, abcName, abcTimeSampling);
  this_->handle = new PtrHandle<AbcG::OPoints>(abcThis_, true);
    ",
    "AlembicOPointsSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOPointsSchema_free": "  free_AbcBasePtr(AbcG::OPointsSchema)\n  ",
    "AlembicOPointsSample_construct": "  construct_AbcBasePtr(AbcG::OPointsSchema::Sample)\n  ",
    "AlembicOPointsSample_free": "  free_AbcBasePtr(AbcG::OPointsSchema::Sample)\n  ",
    "AlembicOPointsSample_getPositions": "  AlembicOExtractExternalArrayFromSample(Abc::P3fArraySample, KL::Vec3, getPositions)",
    "AlembicOPointsSample_setPositions": "  AlembicPackExternalArrayToSample(Abc::P3fArraySample, Abc::V3f, setPositions)",
    "AlembicOPointsSample_getIds": "  AlembicOExtractExternalArrayFromSample(Abc::UInt64ArraySample, KL::UInt64, getIds)",
    "AlembicOPointsSample_setIds": "  AlembicPackExternalArrayToSample(Abc::UInt64ArraySample, Abc::uint64_t, setIds)",
    "AlembicOPointsSample_getVelocities": "  AlembicOExtractExternalArrayFromSample(Abc::V3fArraySample, KL::Vec3, getVelocities)",
    "AlembicOPointsSample_setVelocities": "  AlembicPackExternalArrayToSample(Abc::V3fArraySample, Abc::V3f, setVelocities)",
    "AlembicOPointsSample_getWidths": "
  AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample(abcThis_->getWidths());
  conv_to_AbcBasePtr<KL::AlembicOFloat32GeomParamSample, AbcG::OTypedGeomParam<Abc::Float32TPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOPolyMesh_construct": "  this_->handle = NULL;\n  ",
    "AlembicOPolyMesh_free": "  free_AbcBasePtr(AbcG::OPolyMesh)\n  ",
    "AlembicOPolyMesh_matches": "  return AbcG::OPolyMesh::matches(*abcMetaData);\n  ",
    "AlembicOPolyMesh_construct3Args": "
  AbcG::OPolyMesh * abcThis = new AbcG::OPolyMesh(*abcParent, std::string(name.data()), timeSampling);
  this_->handle = new PtrHandle<AbcG::OPolyMesh>(abcThis, true);
    ",
    "AlembicOPolyMeshSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOPolyMeshSchema_free": "  free_AbcBasePtr(AbcG::OPolyMeshSchema)\n  ",
    "AlembicOPolyMeshSchema_getFaceSetNames": "
  std::vector<std::string> abc_result;
  abcThis_->getFaceSetNames(abc_result);
  _result.resize(abc_result.size());
  for(size_t i=0;i<abc_result.size();i++)
    _result[i] = abc_result[i].c_str();
    ",
    "AlembicOPolyMeshSample_construct": "  construct_AbcBasePtr(AbcG::OPolyMeshSchema::Sample)\n  ",
    "AlembicOPolyMeshSample_free": "  free_AbcBasePtr(AbcG::OPolyMeshSchema::Sample)\n  ",
    "AlembicOPolyMeshSample_getPositions": "  AlembicOExtractExternalArrayFromSample(Abc::P3fArraySample, KL::Vec3, getPositions)",
    "AlembicOPolyMeshSample_setPositions": "  AlembicPackExternalArrayToSample(Abc::P3fArraySample, Abc::V3f, setPositions)",
    "AlembicOPolyMeshSample_getVelocities": "  AlembicOExtractExternalArrayFromSample(Abc::V3fArraySample, KL::Vec3, getVelocities)",
    "AlembicOPolyMeshSample_setVelocities": "  AlembicPackExternalArrayToSample(Abc::V3fArraySample, Abc::V3f, setVelocities)",
    "AlembicOPolyMeshSample_getFaceIndices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getFaceIndices)",
    "AlembicOPolyMeshSample_setFaceIndices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setFaceIndices)",
    "AlembicOPolyMeshSample_getFaceCounts": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getFaceCounts)",
    "AlembicOPolyMeshSample_setFaceCounts": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setFaceCounts)",
    "AlembicOPolyMeshSample_getUVs": "
  AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample(abcThis_->getUVs());
  conv_to_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOPolyMeshSample_getNormals": "
  AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample(abcThis_->getNormals());
  conv_to_AbcBasePtr<KL::AlembicOVec3NfGeomParamSample, AbcG::OTypedGeomParam<Abc::N3fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOScalarProperty_construct": "  this_->handle = NULL;\n  ",
    "AlembicOScalarProperty_free": "  free_AbcBasePtr(Abc::OScalarProperty)\n  ",
    "AlembicOScalarProperty_construct3Args": "
  Abc::OScalarProperty * abcThis_ = new Abc::OScalarProperty(*abcParent, abcName, abcDataType);
  this_->handle = new PtrHandle<Abc::OScalarProperty>(abcThis_, true);
    ",
    "AlembicOScalarProperty_getHeader": "  AlembicPropertyGetHeader()",
    "AlembicOScalarProperty_getMetaData": "  AlembicGetMetaData()",
    "AlembicOScalarProperty_setAsBoolean": "  AlembicOScalarPropertySetExport(Boolean, kBooleanPOD)",
    "AlembicOScalarProperty_setAsUInt8": "  AlembicOScalarPropertySetExport(UInt8, kUint8POD)",
    "AlembicOScalarProperty_setAsSInt8": "  AlembicOScalarPropertySetExport(SInt8, kInt8POD)",
    "AlembicOScalarProperty_setAsUInt16": "  AlembicOScalarPropertySetExport(UInt16, kUint16POD)",
    "AlembicOScalarProperty_setAsSInt16": "  AlembicOScalarPropertySetExport(SInt16, kInt16POD)",
    "AlembicOScalarProperty_setAsUInt32": "  AlembicOScalarPropertySetExport(UInt32, kUint32POD)",
    "AlembicOScalarProperty_setAsSInt32": "  AlembicOScalarPropertySetExport(SInt32, kInt32POD)",
    "AlembicOScalarProperty_setAsUInt64": "  AlembicOScalarPropertySetExport(UInt64, kUint64POD)",
    "AlembicOScalarProperty_setAsSInt64": "  AlembicOScalarPropertySetExport(SInt64, kInt64POD)",
    "AlembicOScalarProperty_setAsFloat16": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() != Abc::kFloat16POD)
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicOScalarProperty_setAsFloat16: DataType.pod() not kFloat16POD.\");

  std::vector<Abc::float16_t> floats(values.size());
  for(size_t i=0;i<floats.size();i++)
    floats[i] = (Abc::float16_t)values[i];
  abcThis_->set(&floats[0]);
    ",
    "AlembicOScalarProperty_setAsFloat32": "  AlembicOScalarPropertySetExport(Float32, kFloat32POD)",
    "AlembicOScalarProperty_setAsFloat64": "  AlembicOScalarPropertySetExport(Float64, kFloat64POD)",
    "AlembicOScalarProperty_setAsString": "
  const Abc::PropertyHeader & header = abcThis_->getHeader();
  if(header.getDataType().getExtent() == 0)
    return;
  if(header.getDataType().getPod() == Abc::kStringPOD)
  {
    std::vector<std::string> strings(values.size());
    for(size_t i=0;i<strings.size();i++) 
    {
      if(values[i].data() == NULL || values[i].length() == 0)
        strings[i].clear();
      else
        strings[i] = values[i].data();
    }
    abcThis_->set(&strings[0]);
  }
  else if(header.getDataType().getPod() == Abc::kWstringPOD)
  {
    std::vector<std::wstring> wstrings(values.size());
    for(size_t i=0;i<wstrings.size();i++) 
    {
      if(values[i].data() == NULL || values[i].length() == 0)
        wstrings[i].clear();
      else
      {
        std::string s = values[i].data();
        for(size_t j=0;j<s.length();j++)
          wstrings[i] += s[j];
      }
    }
    abcThis_->set(&wstrings[0]);
  }
  else
    FABRIC_EXT_SETERROR_AND_RETURN(\"AlembicOScalarProperty_setAsString: DataType.pod() not kStringPOD / kWstringPOD.\");
    ",

    "AlembicOSubD_construct": "  this_->handle = NULL;\n  ",
    "AlembicOSubD_free": "  free_AbcBasePtr(AbcG::OSubD)\n  ",
    "AlembicOSubD_matches": "  return AbcG::OSubD::matches(*abcMetaData);\n  ",
    "AlembicOSubD_construct3Args": "
  AbcG::OSubD * abcThis = new AbcG::OSubD(*abcParent, std::string(name.data()), timeSampling);
  this_->handle = new PtrHandle<AbcG::OSubD>(abcThis, true);
    ",
    "AlembicOSubDSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOSubDSchema_free": "  free_AbcBasePtr(AbcG::OSubDSchema)\n  ",
    "AlembicOSubDSchema_getFaceSetNames": "
  std::vector<std::string> abc_result;
  abcThis_->getFaceSetNames(abc_result);
  _result.resize(abc_result.size());
  for(size_t i=0;i<abc_result.size();i++)
    _result[i] = abc_result[i].c_str();
    ",
    "AlembicOSubDSample_construct": "  construct_AbcBasePtr(AbcG::OSubDSchema::Sample)\n  ",
    "AlembicOSubDSample_free": "  free_AbcBasePtr(AbcG::OSubDSchema::Sample)\n  ",
    "AlembicOSubDSample_getPositions": "  AlembicOExtractExternalArrayFromSample(Abc::P3fArraySample, KL::Vec3, getPositions)",
    "AlembicOSubDSample_setPositions": "  AlembicPackExternalArrayToSample(Abc::P3fArraySample, Abc::V3f, setPositions)",
    "AlembicOSubDSample_getVelocities": "  AlembicOExtractExternalArrayFromSample(Abc::V3fArraySample, KL::Vec3, getVelocities)",
    "AlembicOSubDSample_setVelocities": "  AlembicPackExternalArrayToSample(Abc::V3fArraySample, Abc::V3f, setVelocities)",
    "AlembicOSubDSample_getFaceIndices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getFaceIndices)",
    "AlembicOSubDSample_setFaceIndices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setFaceIndices)",
    "AlembicOSubDSample_getFaceCounts": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getFaceCounts)",
    "AlembicOSubDSample_setFaceCounts": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, Abc::int32_t, setFaceCounts)",
    "AlembicOSubDSample_getCreaseIndices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getCreaseIndices)",
    "AlembicOSubDSample_setCreaseIndices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, KL::SInt32, setCreaseIndices)",
    "AlembicOSubDSample_getCreaseLengths": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getCreaseLengths)",
    "AlembicOSubDSample_setCreaseLengths": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, KL::SInt32, setCreaseLengths)",
    "AlembicOSubDSample_getCreaseSharpnesses": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getCreaseSharpnesses)",
    "AlembicOSubDSample_setCreaseSharpnesses": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, KL::Float32, setCreaseSharpnesses)",
    "AlembicOSubDSample_setCreases2Args": "
  Abc::Int32ArraySample indicesSample;
  if(indices.size() > 0)
    indicesSample = Abc::Int32ArraySample((const Abc::int32_t *)&indices[0], indices.size());
  Abc::Int32ArraySample lengthsSample;
  if(lengths.size() > 0)
    lengthsSample = Abc::Int32ArraySample((const Abc::int32_t *)&lengths[0], lengths.size());
  abcThis_->setCreases(indicesSample, lengthsSample);
    ",
    "AlembicOSubDSample_setCreases3Args": "
 Abc::Int32ArraySample indicesSample;
  if(indices.size() > 0)
    indicesSample = Abc::Int32ArraySample((const Abc::int32_t *)&indices[0], indices.size());
  Abc::Int32ArraySample lengthsSample;
  if(lengths.size() > 0)
    lengthsSample = Abc::Int32ArraySample((const Abc::int32_t *)&lengths[0], lengths.size());
  Abc::FloatArraySample sharpnessesSample;
  if(sharpnesses.size() > 0)
    sharpnessesSample = Abc::FloatArraySample((const Abc::float32_t *)&sharpnesses[0], sharpnesses.size());
  abcThis_->setCreases(indicesSample, lengthsSample, sharpnessesSample);
    ",
    "AlembicOSubDSample_getCornerIndices": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getCornerIndices)",
    "AlembicOSubDSample_setCornerIndices": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, KL::SInt32, setCornerIndices)",
    "AlembicOSubDSample_getCornerSharpnesses": "  AlembicOExtractExternalArrayFromSample(Abc::FloatArraySample, KL::Float32, getCornerSharpnesses)",
    "AlembicOSubDSample_setCornerSharpnesses": "  AlembicPackExternalArrayToSample(Abc::FloatArraySample, KL::Float32, setCornerSharpnesses)",
    "AlembicOSubDSample_getHoles": "  AlembicOExtractExternalArrayFromSample(Abc::Int32ArraySample, KL::SInt32, getHoles)",
    "AlembicOSubDSample_setHoles": "  AlembicPackExternalArrayToSample(Abc::Int32ArraySample, KL::SInt32, setHoles)",
    "AlembicOSubDSample_setCorners2Args": "
  Abc::Int32ArraySample indicesSample;
  if(indices.size() > 0)
    indicesSample = Abc::Int32ArraySample((const Abc::int32_t *)&indices[0], indices.size());
  Abc::FloatArraySample sharpnessesSample;
  if(sharpnesses.size() > 0)
    sharpnessesSample = Abc::FloatArraySample((const Abc::float32_t *)&sharpnesses[0], sharpnesses.size());
  abcThis_->setCorners(indicesSample, sharpnessesSample);
    ",
    "AlembicOSubDSample_getUVs": "
  AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample * abc_result = new AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample(abcThis_->getUVs());
  conv_to_AbcBasePtr<KL::AlembicOVec2VfGeomParamSample, AbcG::OTypedGeomParam<Abc::V2fTPTraits>::Sample>(abc_result, _result, true);
    ",
    "AlembicOXform_construct": "  this_->handle = NULL;\n  ",
    "AlembicOXform_free": "  free_AbcBasePtr(AbcG::OXform)\n  ",
    "AlembicOXform_matches": "  return AbcG::OXform::matches(*abcMetaData);\n  ",
    "AlembicOXform_construct3Args": "
  AbcG::OXform * abcThis = new AbcG::OXform(*abcParent, std::string(name.data()), timeSampling);
  this_->handle = new PtrHandle<AbcG::OXform>(abcThis, true);
    ",
    "AlembicOXformSchema_construct": "  this_->handle = NULL;\n  ",
    "AlembicOXformSchema_free": "  free_AbcBasePtr(AbcG::OXformSchema)\n  ",
    "AlembicPropertyHeader_construct": "  construct_AbcBasePtr(AbcG::PropertyHeader)\n  ",
    "AlembicPropertyHeader_free": "  free_AbcBasePtr(AbcG::PropertyHeader)\n  ",
    "AlembicPropertyHeader_construct2Args": "
  this_->handle = new PtrHandle<Abc::PropertyHeader>(new Abc::PropertyHeader(abcName, *abcMetaData), true);
    ",
    "AlembicPropertyHeader_construct5Args": "
  this_->handle = new PtrHandle<Abc::PropertyHeader>(new Abc::PropertyHeader(
    abcName, 
    (Abc::PropertyType)abcPropType,
    *abcMetaData,
    abcDataType,
    abcTimeSampling
  ), true);
    ",
    "AlembicPropertyHeader_setPropertyType": "  abcThis_->setPropertyType((Abc::PropertyType)abcPropType);\n  ",
    "AlembicPropertyHeader_getMetaData": "  
  Abc::MetaData * abc_result = new Abc::MetaData(abcThis_->getMetaData());
  conv_to_AbcBasePtr<KL::AlembicMetaData, Abc::MetaData>(abc_result, _result, true);
    ",
    "AlembicTimeSampling_construct": "  construct_AbcBase(Abc::TimeSamplingPtr)\n  ",
    "AlembicTimeSampling_free": "  free_AbcBase(Abc::TimeSamplingPtr)\n  ",
    "AlembicTimeSampling_constructFromSamplingType": "
  std::vector<Abc::chrono_t> abcSampleTimes(sampleTimes.size());
  for(uint32_t i=0;i<sampleTimes.size();i++)
    abcSampleTimes[i] = sampleTimes[i];

  Abc::TimeSamplingPtr timeSamplingPtr(new Abc::TimeSampling(abcSamplingType, abcSampleTimes));
  this_->handle = new Handle<Abc::TimeSamplingPtr>(timeSamplingPtr);
    ",
    "AlembicTimeSampling_constructFromStartTime": "
  Abc::TimeSamplingPtr timeSamplingPtr(new Abc::TimeSampling((Abc::chrono_t)timePerCycle, (Abc::chrono_t)startTime));
  this_->handle = new Handle<Abc::TimeSamplingPtr>(timeSamplingPtr);
    ",
    "AlembicTimeSampling_getStoredTimes": "
  const std::vector<Abc::chrono_t> & abcResult = abcThis_->getStoredTimes();
  _result.resize(abcResult.size());
  for(uint32_t i=0;i<_result.size();i++)
    _result[i] = abcResult[i];
    ",
    "AlembicTimeSamplingType_construct": "  construct_AbcBase(Abc::TimeSamplingType)\n  ",
    "AlembicTimeSamplingType_free": "  free_AbcBase(Abc::TimeSamplingType)\n  ",
    "AlembicTimeSamplingType_constructFromFloat64": "
  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType((Abc::chrono_t)timePerCycle));
    ",
    "AlembicTimeSamplingType_constructFromUInt32Float64": "
  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType(numSamplesPerCycle, (Abc::chrono_t)timePerCycle));
    ",
    "AlembicTimeSamplingType_constructFromAcyclicFlag": "
  this_->handle = new Handle<Abc::TimeSamplingType>(Abc::TimeSamplingType((Abc::TimeSamplingType::AcyclicFlag)flag));
    ",
    "AlembicISampleSelector_construct": "  this_->handle = NULL;\n  ",
    "AlembicISampleSelector_free": "  free_AbcBasePtr(AbcG::ISampleSelector)\n  ",
    "AlembicISampleSelector_constructFromReqIdx": "
  Abc::ISampleSelector * abcThis_ = new Abc::ISampleSelector((Abc::index_t)reqIdx);
  this_->handle = new PtrHandle<Abc::ISampleSelector>(abcThis_, true);
    ",
    "AlembicISampleSelector_constructFromReqTime": "
  Abc::ISampleSelector * abcThis_ = new Abc::ISampleSelector((Abc::chrono_t)reqTime, (Abc::ISampleSelector::TimeIndexType)reqIdxType);
  this_->handle = new PtrHandle<Abc::ISampleSelector>(abcThis_, true);
    ",

    "lastentry": ""
  },
  "parameterconversionstoskip": [
    "AlembicICamera_matches.this_",
    "AlembicICurves_matches.this_",
    "AlembicILight_matches.this_",
    "AlembicINuPatch_matches.this_",
    "AlembicIPoints_matches.this_",
    "AlembicIPolyMesh_matches.this_",
    "AlembicISubD_matches.this_",
    "AlembicIXform_matches.this_",
    "AlembicICamera_matches.this_",
    "AlembicICurves_matches.this_",
    "AlembicILight_matches.this_",
    "AlembicINuPatch_matches.this_",
    "AlembicIPoints_matches.this_",
    "AlembicIPolyMesh_matches.this_",
    "AlembicISubD_matches.this_",
    "AlembicIXform_matches.this_"
  ]
}

